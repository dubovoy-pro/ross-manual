---
title: "Философия ROSS"
description: ""
lead: ""
draft: false
images: []
menu:
  docs:
    parent: "overview"
weight: 120
toc: true
---

Помимо 3-х ключевых параметров архитектуры (пластичность, тестируемость и наглядность) есть еще один очень важный параметр — это простота. При разработке новой функциональности или рефакторинге я хочу двигаться по четкому, наглядному дереву решений, которое позволит мне легко определить, куда именно следует добавить или перенести тот или иной код. Я хочу думать над бизнес-логикой, а не над «каноничностью» архитектурных элементов. Это удается, если код легко классифицируется и отношения между классами четко определены. Рассмотрим, что нам предлагает получившийся базис ROSS, на практическом примере. Допустим, у меня есть экран с табличными данными, для отображения которых нужно выполнить цепочку сетевых запросов с промежуточной обработкой ответов на клиенте. Где лучше разместить этот код запросов и обработки: во вью-модели, операции или ключевом сервисе?
Сетевой запрос — это императивный вызов, следовательно, за его выполнение должен отвечать сервис, т.к. императивный интерфейс есть только у него. Если запросы и данные никак не касаются других экранов, то этим сервисом будет вью-модель, т.к. вью-модель изначально специализируется на обслуживании конкретного экрана (вью-контроллера). Если же эти же запросы и данные используются в других экранах, то логично вынести их в отдельный специализированный сервис. Если мы понимаем, что для решения задачи придется вызывать другую операцию, то нужно сначала выяснить, можем ли мы завершить текущую операцию, вернуть управление в сценарий и запустить другую операцию оттуда. Если нет, например, когда требуется вернуть поток управления в текущую операцию, то придется преобразовать текущую операцию в отдельный сценарий.

Подведем итоги. Архитектура построена на базисе из 4-х компонентов: Router, Operation, Service, Scenario. Символично, что по-русски звучит точно так же! Для того, чтобы базис ROSS работал, нужно придерживаться следующего набора из 10 правил или «важных мелочей»:
1. покрытие тестами на 100% невозможно и бессмысленно. AppDelegate тестами не покрываем, но все, что можно из него убрать — убираем.
2. асинхронные операции и сценарии должны сами позаботиться о своем выживании — используем искусственный retain-cycle.
3. следует различать жесткие и контекстные зависимости. Контекстные очень гибкие, но их нужно покрывать тестами.
4. у фабрики операций есть доступ к контейнеру с уже настроенными ключевыми сервисами => пластичность операций.
5. вью-модель изолирует бизнес-логику операции от UI-логики роутера => наглядность операции.
6. операция передает вью-модель на вход роутеру => тестируемость операции.
7. чтобы обеспечить одновременно тестируемость и пластичность, активно используем фабрики (операций, сценариев и вью-моделей).
8. следует различать бизнес-логику и есть UI-логику.
9. как только у операции возникает потребность обратиться к другой операции, она превращается в сценарий. Операция неделима!
10. сценарии может запускать только сервис.

Базис ROSS в связке с набором «важных мелочей» формирует архитектуру, которая отвечает всем требованиям к построению сложных клиентских приложений. Основным достоинством архитектуры ROSS является ее простота в сочетании с высокой тестируемостью. Малое количество сущностей и четко прописанные различия между ними позволяют легко определять, куда какой код добавлять и как его именовать. Обратной стороной такой простоты является необходимость в документации: источником правды является не код, а диаграммы сообщений и диаграммы операций. На основе одного лишь нейминга без документации, т.е. контекста, становится сложно понять, почему те или иные операции или сценарии работают именно так, а не иначе. Вместе с тем наличие диаграмм сообщений, операций, классов и прецедентов позволяет аналитикам, проектировщикам, разработчикам и тестировщикам обмениваться контекстом на общем, едином языке.