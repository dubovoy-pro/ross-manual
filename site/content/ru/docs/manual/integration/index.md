---
title: "Внедрение в существующие проекты"
description: ""
lead: ""
draft: false
images: []
menu:
  docs:
    parent: "help"
weight: 350
toc: true
---

Независимо от используемой архитектуры любое приложение можно рассматривать как один большой объект, который обладает состоянием и содержит методы UX-взаимодействия. В терминах ROSS состоянием обладает только одна сущность – сервис. Этот сервис по определению является ключевым. Если предоставить ему доступ к фабрике сценариев, то сервис превратится в AppService. Останется только определить, какая часть приложения (какой класс) будет реализовывать протокол  IAppService, после чего можно считать, что ROSS интегрирована в текущее приложение. Все новые пользовательские сценарии можно будет уже свободно формировать в ROSS-компонентах.

Разумеется, чтобы полностью задействовать преимущества  ROSS (высокий уровень наглядности, пластичности и тестируемости), необходимо перевести на ROSS-рельсы оставшуюся часть приложения. Процесс выполняется в несколько шагов:

1. Заменяем неявные зависимости на явные. Устраняем синглтоны, сервис-локаторы, DI-контейнеры, бродкаст-сообщения, статические порождающие функции и т.п.
1. Инкапсулируем UI-слой, формируем роутер. Инстанцирование всех  UI-компонентов должно выполняться в роутере, по запросу через методы в интерфейсе роутера. В качестве контекста в эти методы передаем вью-модели. Роутер пробрасывается в качестве зависимости во все точки, где требуется UI.
1. Переносим ответственности из объемных общих сущностей (координатор, контроллер приложения и т.п.) в специализированные ключевые сервисы, формируем контейнер ключевых сервисов.
1. Формируем операцию по инициализации ключевых сервисов, добавляем метод по созданию операции в фабрику операций.
1. Формируем сценарий входа в приложение, формируем составляющие сценарий операции (один из самых наглядных и линейных  UserFlow).
1. Реализуем тесты на сценарий входа, а также на задействованные в нем операции и сервисы.
1. Реализуем UI-тест на сценарий входа.
1. Обеспечиваем наглядность: формируем диаграмму операций для сценария, диаграммы сообщений для операций и диаграммы состояний для сервисов (если требуется, то и диаграмму сервисов для отображения зависимостей между сервисами).
1. Повторяем пункты 5-8 для всех UserFlow в приложении.

В результате такого преобразования получаем полностью простестированную кодовую базу, снабженную актуальной и наглядной документацией. В дальнейшем разработка новых UserFlow начинается с проектирования, а именно с построения диаграмм. Это позволяет формировать более точную оценку трудозатрат, поскольку:

1. Граничные случаи выявляются на раннем этапе (например, «хвосты» на диаграмме операций);
2. Заранее выявляется общее количество операций и сервисов, задействованных в UserFlow. Без диаграмм разработчик может полагаться только на количество экранов и переходов между ними в дизайн-макетах, да на количество эндпоинтов в swagger-описаниях.
3. Наглядное описание UserFlow облегчает декомпозицию и распределение задач в команде разработки.
